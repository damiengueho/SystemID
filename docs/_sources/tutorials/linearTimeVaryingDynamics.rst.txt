Linear Time-Varying (LTV) Dynamics
==================================


Example 1: Point Mass in a Rotating Tube
########################################

Description of the problem
--------------------------

.. image:: ../images/Tutorials/LTVDynamics/PointMassInRotatingTube/setup.png
  :align: center
  :width: 350
  :alt: Alternative text

Consider the dynamics of a point mass in a rotating tube governed by a second order differential equation given by

.. math::

   \delta\ddot{r}(t) = \left(\dot{\theta}^2(t)-\dfrac{k}{m}\right)\delta r(t)+u(t)+l\dot{\theta}^2(t)

where the new variable :math:`\delta r(t) = r(t) - l` has been introduced, together with the definition of :math:`l`,
as the free length of the spring (when no force is applied on it, i.e., Hookeâ€™s Law applies as :math:`F_s = -k\delta r`).
The function :math:`u(t)` is the radial control force applied on the point mass, and the parameters :math:`k` and :math:`m` are the
spring stiffness and the mass of the point mass of interest. The time variation in this linear system is brought about
by the profile of the angular velocity of the rotating tube :math:`\dot{\theta}(t)`. Choosing the origin of the coordinate
system at the position :math:`r_0 = l` (with no loss of generality), the second order differential equation is given by

.. math::

    \delta\ddot{r}(t) = \left(\dot{\theta}^2(t)-\dfrac{k}{m}\right)\delta r(t)+u(t)

where the redefinition of the origin renders the system linear time varying without any extra forcing functions.
In the first order state space form (:math:`x_1(t) = \delta r(t), x_2(t) = \delta\dot{r}(t)`), the equations can
be written as

.. math::

    \begin{bmatrix} \dot{x}_1(t)\\
                    \dot{x}_2(t)
    \end{bmatrix}
    =
    \begin{bmatrix} 0 & 1\\
                    \dot{\theta}^2(t)-\dfrac{k}{m} & 0
    \end{bmatrix}
    \begin{bmatrix} x_1(t)\\
                    x_2(t)
    \end{bmatrix} +
    \begin{bmatrix} 0\\
                    1
    \end{bmatrix}u(t) =
    A(t)\boldsymbol{x}(t) + B(t)u(t)

together with the measurement equations

.. math::

    \begin{bmatrix} y_1(t)\\
                    y_2(t)
    \end{bmatrix} =
    \begin{bmatrix} 1 & 0\\
                    0 & 1
    \end{bmatrix}
    \begin{bmatrix} x_1(t)\\
                    x_2(t)
    \end{bmatrix} +
    \begin{bmatrix} 0\\
                    1
    \end{bmatrix}u(t) =
    C(t)\boldsymbol{x}(t) + D(t)u(t).

To compare with the identified models, analytical discrete-time models are generated by computing the state
transition matrix (equivalent :math:`A_k`) and the convolution integrals (equivalent :math:`B_k` with a zero order
hold assumption on the inputs). Because the system matrices are time varying, matrix differential equations are given by

.. math::

    \dot{\Phi}(t, t_k) = A(t)\Phi(t, t_k), \quad \dot{\Psi}(t, t_k) = A(t)\Psi(t, t_k) + I,

:math:`\forall \ t \in [t_k, t_{k+1}]`, with initial conditions

.. math::

    \Phi(t_k, t_k) = \begin{bmatrix} 1 & 0\\
                                     0 & 1
                     \end{bmatrix}, \quad
    \Psi(t_k, t_k) = \begin{bmatrix} 0 & 0\\
                                     0 & 0
                     \end{bmatrix}

such that

.. math::

    A_k = \Phi(t_{k+1}, t_k), \quad B_k = \Psi(t_{k+1}, t_k)B,

would represent the equivalent discrete-time varying system (true  model). For the current investigation, the time
variation profile of :math:`\dot{\theta}(t) = 3\sin(\frac{1}{2}t)`, with the mass and stiffness of the system
chosen to be :math:`m=1` and :math:`k=10`, respectively. The time interval of interest is :math:`10` seconds,
with the discretization sampling frequency set to be :math:`10` Hz. In that example, :math:`u(t) = 0` and this is
considered an initial condition response experiment.


Code using systemID
-------------------

.. code-block:: python

   ## Define parameters
    dt = 0.1
    mass = 1
    spring_constant = 10
    def theta_dot(t):
        return 3 * np.sin(t/2)


    ## Define dynamics
    dynamics = PointMassInRotatingTubeDynamics(dt, mass, spring_constant, theta_dot)


    ## Define Training Experiments
    frequency = 1 / dt
    total_time_training = 11
    number_steps_training = int(total_time_training * frequency + 1)
    number_experiments = 20
    input_signals_training = []
    systems_training = []
    for i in range(number_experiments):
        input_signals_training.append(DiscreteSignal(dynamics.input_dimension, total_time_training, frequency))
        systems_training.append(DiscreteLinearSystem(frequency, dynamics.state_dimension, dynamics.input_dimension, dynamics.output_dimension, [(np.random.randn(2), 0)], 'Original System', dynamics.A, dynamics.B, dynamics.C, dynamics.D))
    training_experiments = Experiments(systems_training, input_signals_training)


    ## TVERAIC
    assumed_state_dimension = dynamics.state_dimension
    p = 10
    tveraic = TVERAFromInitialConditionResponse(training_experiments, assumed_state_dimension, p)


    ## Testing data
    total_time_testing = 10
    input_signal_testing = DiscreteSignal(dynamics.input_dimension, total_time_testing, frequency)
    initial_states = [(np.array([2, -1]), 0)]
    true_system = DiscreteLinearSystem(frequency, dynamics.state_dimension, dynamics.input_dimension, dynamics.output_dimension, initial_states, 'True System', dynamics.A, dynamics.B, dynamics.C, dynamics.D)


    ## Output
    true_output = OutputSignal(input_signal_testing, true_system)


    ## Identify IC
    x0_id = identificationInitialCondition(input_signal_testing, true_output, tveraic.A, tveraic.B, tveraic.C, tveraic.D, 0, p)


    ## Identified System
    identified_system = DiscreteLinearSystem(frequency, assumed_state_dimension, dynamics.input_dimension, dynamics.output_dimension, [(x0_id, 0)], 'Identified System', tveraic.A, tveraic.B, tveraic.C, tveraic.D)


    ## Identified Output Signal
    identified_output = OutputSignal(input_signal_testing, identified_system)


Results
-------
The error incurred in the response is shown below.

.. image:: ../images/Tutorials/LTVDynamics/PointMassInRotatingTube/propagation.png
  :align: center
  :width: 800
  :alt: Alternative text

The singular value decomposition plot is displayed at different time instants.

.. image:: ../images/Tutorials/LTVDynamics/PointMassInRotatingTube/svd.png
  :align: center
  :width: 400
  :alt: Alternative text

Finally, the eigenvalues of the time varying :math:`A_k` matrix are shown before:

.. image:: ../images/Tutorials/LTVDynamics/PointMassInRotatingTube/eigenvalues.png
  :align: center
  :width: 800
  :alt: Alternative text

and after correction:

.. image:: ../images/Tutorials/LTVDynamics/PointMassInRotatingTube/eigenvalues_corrected.png
  :align: center
  :width: 800
  :alt: Alternative text









